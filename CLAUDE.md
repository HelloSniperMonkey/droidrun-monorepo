1.First think through the problem, read the codebase for relevant files, and write a plan to tasks/todo.md. Always ask questions if anything is unclear, and NEVER ASSUME.
2.The plan should have a list of todo items that you can check off as you complete them
3.Before you begin working, check in with me and I will verify the plan.
4.Then, begin working on the todo items, marking them as complete as you go.
5.Please every step of the way just give me a high level explanation of what changes you made
6.Make every task and code change you do as simple as possible. We want to avoid making any massive or complex changes. Every change should impact as little code as possible. Everything is about simplicity.
7.Make sure security is tight and always production ready, no matter the cirumstance.
8. Also before coding, always have this perspective of “what would Mark Zuckerburg do in this situation”
9.After execution, please check through all the code you just wrote and make sure it follows security best practices. make sure there are no sensitive information in the front and and there are no vulnerabilities that can be exploited, and no crucial files like .env, and also before pushing to github check as well. And also please explain the functionality and code you just built out in detail. Walk me through what you changed and how it works. Act like you’re a senior engineer teaching a 16 year old how to code.
8.Finally, add a review section to the [todo.md](http://todo.md/) file with a summary of the changes you made and any other relevant information.
9.And also, always check for syntax errors after code completion

10. I need you to create the project in a mono repo fashion so that multiple agents can work on it simeltaneously [previously pants(for python backend) + turborepo(for nextjs frontend) was used]
11. i need fast itteration speed so you may ignore some safety and privacy related features but dont ignore them completely.
12. use context7 for any library related documentation. search droidrun, mobilerun
13. for the mvp stage mobilerun can handle most of the server heavy tasks we mostly need to make api calls form the server and sync it up with other services like vapi  

Project Iron Claw: A Mobile-First Autonomous Agent Architecture1. Executive Vision and Strategic Context1.1 The Shift from API-Mediated to UI-Native AutonomyThe current paradigm of software automation relies heavily on Application Programming Interfaces (APIs). In this "API Economy," automation is robust but severely limited in scope. It is restricted to the "walled gardens" where developers have explicitly built gates for machines to enter. If an application lacks a public API—or if that API is deprecated, rate-limited, or paywalled—it effectively does not exist to the traditional bot. This creates a bifurcation in the digital world: the clean, structured, but small world of APIs, and the messy, visual, infinite world of User Interfaces (UIs).Project Iron Claw represents a strategic pivot toward "UI-Native Autonomy." By leveraging Droidrun—a framework that allows Large Language Models (LLMs) to perceive and interact with Android accessibility trees—we enable an agent to operate in the UI world.1 This allows the agent to use any app installed on a smartphone, effectively turning the entire Google Play Store into a tool library for the AI.This shift is analogous to the evolution from command-line interfaces to graphical user interfaces (GUIs) for humans. We are now enabling the reverse: machines that can navigate human GUIs. This capability is critical for personal agents because the "personal" digital life—messaging, social media, gig work apps, banking—is overwhelmingly mobile-first and API-hostile.1.2 The "Clawdbot" Pattern AdaptationThe architecture proposed here adapts the "Clawdbot" pattern for mobile execution. The original Clawdbot is a "local-first" personal assistant designed to run on a user's machine, integrating with messaging channels (WhatsApp, Telegram) and executing tasks via a local Gateway.2For Project Iron Claw, we modify this pattern to accommodate the mobile constraint. Since smartphones cannot easily host the heavy "Gateway" logic and LLM inference themselves (due to thermal and battery constraints), we decouple the Control Plane from the Execution Plane.Control Plane (The Gateway): A persistent server (VPS or Home Server) running the "Clawdbot" logic—handling user intent, scheduling, and API integrations like Vapi.Execution Plane (The Body): A Mobilerun Cloud instance—a hosted Android environment that serves as the agent's physical avatar.3Perception Layer (The Eyes): Droidrun, which translates the visual pixels and XML hierarchy of the Android screen into semantic text for the LLM.41.3 Key Objectives and ScopeThe Minimum Viable Product (MVP) defined in this report targets three high-value, complex workflows that demonstrate the superiority of UI-Native agents over traditional scripts:The Job Hunter: Autonomously navigating the mobile web to find and apply for jobs, bypassing the anti-bot defenses that plague standard scrapers.The Temporal Guardian: Managing the user's sleep and wake cycles through precise, intent-based alarm scheduling on the native Android clock.The Active Interrupter: Using Vapi (Voice API) to bridge the gap between digital notification and physical attention, calling the user at 2:00 AM based on their geolocation to ensure wakefulness.62. Comprehensive System ArchitectureThe Iron Claw system is a distributed system composed of three primary nodes: the Gateway, the Mobilerun Instance, and the External Integration Layer (Vapi/LLM Providers).2.1 Network Topology and ConnectivityA critical challenge in mobile automation is the connection between the "Brain" (Python script) and the "Body" (Android Device). In a local setup, this is a USB cable. In a cloud setup, it requires robust tunneling.ComponentNetwork ProtocolFunctionSecurity RequirementUser ClientHTTPS (Webhook) / WSSChat Interface (Telegram/Web)TLS 1.3, E2E Encryption where possibleGatewayTCP / SSH TunnelOrchestrator LogicFirewall restricted to known IPsMobilerun DeviceADB over TCP / TLSAndroid Execution EnvironmentMutual TLS (mTLS) or VPN (Tailscale)Vapi ServiceHTTPS (REST) + SIPVoice Telephony BridgeAPI Key AuthenticationLLM ProviderHTTPS (REST)Reasoning Engine (Gemini 1.5)Ephemeral Data Policy2.1.1 The ADB Tunneling ChallengeMobilerun Cloud instances typically expose the Android Debug Bridge (ADB) over a TCP port. ADB is an insecure protocol by default; it transmits keystrokes and screen dumps in cleartext.8Solution: We utilize a secure tunnel (e.g., Tailscale or SSH) to encapsulate the ADB traffic. The Gateway acts as a Tailscale node, and the Mobilerun instance (if supported) or a sidecar proxy connects to the same tailnet.9Implication: The DroidAgent must be configured to connect to localhost:5555 (the tunnel endpoint) rather than a public IP, ensuring that the screen data—which may contain resumes or personal emails—never traverses the public internet unencrypted.2.2 The Gateway (Clawdbot Core)The Gateway is the system's "Prefrontal Cortex." It does not perform the actions itself but decides what actions are necessary.Tech Stack: Python 3.11+, FastAPI (for webhooks), APScheduler (for alarms), and uv for high-performance dependency management.11State Management: Unlike a stateless REST API, the Gateway maintains a persistent state for the agent (e.g., JobApplicationInProgress, WaitingForUserVoiceInput). This requires an asynchronous event loop, efficiently handled by Python's asyncio.Bio-Memory: A local vector store (using sqlite-vec or Chroma) stores the user's parsed resume and preferences. This allows the agent to retrieve "My LinkedIn Password" or "My Years of Python Experience" dynamically during a Droidrun session.22.3 The Execution Plane: Mobilerun & DroidrunThe Mobilerun Cloud instance provides the Android runtime. Droidrun is the software layer that sits on top.The Portal App: Droidrun installs a helper APK (portal.apk) on the device. This app utilizes the AccessibilityService API to dump the AccessibilityNodeInfo hierarchy. This hierarchical data is far richer than a screenshot alone; it contains metadata like resource-id, content-desc, and is-clickable.4The "Manager-Executor" Loop:Observe: Portal App captures Screen + XML.Think: Gateway sends this to Gemini 1.5 Pro. Prompt: "You are applying for a job. The current screen shows a login field. What is the next step?"Act: LLM responds with input_text(element_id=42, text="user@example.com").Execute: Gateway sends ADB command to Portal App to simulate the keystrokes.3. Deep Dive: Feature Implementation Modules3.1 Module A: The "Job Hunter" (Resume Parsing & Application)This module replaces the fragility of web scrapers with the robustness of visual automation.3.1.1 The Failure of Traditional ScrapersStandard job automation tools (e.g., Firecrawl, Selenium scripts) fail because they rely on the underlying HTML Document Object Model (DOM). Job boards like LinkedIn and Indeed defend against this by:DOM Obfuscation: Randomizing class names (e.g., <div class="job-card-xyz123">).Bot Detection: Analyzing the TLS fingerprint of the HTTP client.Behavioral Analysis: Detecting non-human mouse movement trajectories.3.1.2 The Droidrun AdvantageIron Claw bypasses these defenses by operating at the Presentation Layer.Visual Semantics: To an LLM using Droidrun, a button labeled "Apply" looks like an "Apply" button regardless of its underlying HTML class. The visual rendering is intended for humans and therefore remains stable.Mobile Trust: Traffic originating from a mobile Chrome browser (User-Agent: Android) is generally trusted more than desktop traffic. The "Easy Apply" flows on mobile are often simplified, requiring fewer clicks—ideal for an automated agent.13.1.3 Implementation WorkflowResume Ingestion and Parsing:Action: User sends resume.pdf to the Chat Interface.Gateway Process:Saves file to ./data/uploads/.Uses unstructured or PyPDF2 to extract text.Uses an LLM extraction chain to structure the data into JSON:JSON{
  "first_name": "Mark",
  "skills":,
  "experience": [{"role": "CEO", "company": "Meta"}]
}
Crucial Step: The Gateway pushes the PDF to the Mobilerun device via ADB: adb push./data/uploads/resume.pdf /sdcard/Download/. This ensures the file is physically present on the "device" when the upload dialog appears.Search Orchestration:Command: "Apply to Senior Python roles posted in the last 24 hours."Droidrun Logic:Opens com.android.chrome.Navigates to google.com.Types query: Senior Python Jobs remote.Visual Filtering: The agent identifies the "Filter" chip in the Google Jobs widget (often a pill-shaped button). It taps it and selects "Past 24 hours". This visual navigation is robust; scraping the Google Jobs URL parameters is brittle.The "Application Loop":The Agent enters a while loop:Identify Job: Tap the first card.Check Criteria: "Is this 'Senior'? Is it 'Python'?" (LLM verification).Click Apply: Agent identifies the blue "Apply" pill.Handle Redirect: The browser redirects to Greenhouse/Lever/LinkedIn.Form Filling: The LLM maps the Bio-Memory JSON to the form fields on screen.Heuristic: If the field is "First Name", input BioMemory.first_name.Heuristic: If the field is "LinkedIn Profile", input BioMemory.urls.linkedin.File Upload Handling:Agent sees "Upload Resume".Agent taps button -> Android System File Picker opens.Agent navigates: "Hamburger Menu" -> "Downloads" -> "resume.pdf".Note: This requires the agent to recognize native Android system UIs, not just web content. Droidrun excels here because it sees the whole OS, not just the browser window.43.2 Module B: The Temporal Guardian (Calendar & Alarms)This module demonstrates the "Clawdbot" philosophy of integrating deeply with the user's OS, rather than just being a chatbot.3.2.1 Intent-Based Alarm SchedulingThe user interaction is natural language: "Wake me up for the 9 AM standup."Intent Parsing: The Gateway uses a small NLP model (or regex for speed) to extract:Action: SET_ALARMTime: 09:00Label: "Standup"Execution Strategy (Intents vs. UI):While Droidrun could open the Clock app and tap the numbers, this is error-prone (e.g., mis-tapping 8 instead of 9). For critical system functions, we leverage Android Intents via the ADB Shell.Command:Bashadb shell am start -a android.intent.action.SET_ALARM \
  --ei android.intent.extra.alarm.HOUR 9 \
  --ei android.intent.extra.alarm.MINUTES 0 \
  --es android.intent.extra.alarm.MESSAGE "Standup" \
  --zbi android.intent.extra.alarm.SKIP_UI true
This hybrid approach—using Intents for precision and UI for exploration—is the hallmark of a Senior Engineer's architecture. We use the most reliable tool for each sub-task.3.2.2 Calendar ManagementCalendar events often require more context than simple alarms (e.g., "Lunch with Zuck").Execution Strategy:The Agent opens com.google.android.calendar.It uses Droidrun to tap the "Create (+)" FAB.It fills the "Title" and "Time" fields using the keyboard.The Conflict Check: Before scheduling, the Agent can "read" the calendar view. "I see a block at 1 PM labeled 'Deep Work'. Should I schedule over it?" This read-and-reason capability is absent in API-based schedulers that just blindly POST to the Calendar API.3.3 Module C: Vapi Integration (The Active Interrupter)This module addresses the "Attention Economy." Notifications are passive; voice is active.3.3.1 The Geolocation LogicThe prompt specifies: "Call at 2:00 AM based on the user's location." This implies dynamic timezone awareness.The Problem: The user travels from San Francisco (PST) to New York (EST). A static cron job at 2:00 AM PST would ring at 5:00 AM EST (too late) or 11:00 PM EST (too early).The Iron Claw Solution:Location Poll: Every hour, the Gateway triggers a Droidrun check: adb shell dumpsys location.Coordinate Extraction: The Agent parses the GPS coordinates from the dump.Timezone Resolution: The Gateway uses a library like timezonefinder to map (Lat, Long) -> America/New_York.Dynamic Scheduling: The APScheduler job is updated. "Trigger Vapi Call when datetime.now(America/New_York).hour == 2."3.3.2 The Vapi Call ProtocolAt the designated time, the Gateway initiates the call.API Payload:JSON{
  "phoneNumberId": "vapi-phone-id",
  "customer": { "number": "+15550199" },
  "assistant": {
    "voice": "jennifer-playht",
    "systemPrompt": "You are Iron Claw. You are calling to wake the user. You must verify they are awake. Ask them a cognitive question like 'What is 3 times 7?'. Do not hang up until they answer correctly."
  }
}
7Mechanism: Vapi initiates a SIP call to the telephony provider (Twilio/Vonage), which rings the user's physical phone.Latency Handling: Vapi's architecture is optimized for <500ms turn-taking latency. This is crucial. If the user says "I'm awake," and the bot pauses for 3 seconds, the user will hang up. Vapi's turbo-model integration ensures immediate response.64. Interface Design: The Unified ChatThe user interacts with Iron Claw primarily through a chat interface (Telegram or WhatsApp), which serves as the command line for their life.4.1 Chat-Ops and Multimodal FeedbackText Input: Standard commands.Voice Input: The user sends a Voice Note. The Gateway downloads the OGG/MP3 file, uses OpenAI Whisper (or Vapi's transcription API) to convert to text, and then processes it as a standard command.Visual Output (The "Mirror"): When the Droidrun agent is executing a task, it pushes screenshots to the chat.User: "Apply to jobs."Agent: "I found these 3. Applying to the first one..."Agent: "Application submitted."This feedback loop builds trust. The user "sees" the work being done without doing it themselves.4.2 Failure Mode: Human-in-the-Loop (HITL)If Droidrun encounters an unknown state (e.g., a complex visual CAPTCHA), it triggers an HITL event.Agent: Pauses execution.Gateway: Sends the CAPTCHA screenshot to Telegram with buttons: "Retry" | "Abort" | "I solved it".User: Opens the Mobilerun stream URL (WebRTC), solves the CAPTCHA manually on the device, and taps "I solved it" in Telegram.Agent: Resumes execution.5. Execution Plan: The "Senior Engineer" Todo.mdThis strict execution plan prioritizes critical path infrastructure before feature development.Phase 1: Infrastructure & Security (Days 1-2)[ ] Provision Mobilerun Cloud InstanceSecure generic Android 13+ instance.3Security: Configure Firewall to allow ADB connections only from Gateway IP.Networking: Establish Tailscale tunnel between Gateway and Mobilerun to encrypt ADB traffic.9[ ] Gateway Environment SetupInitialize Python 3.11 project with uv.Install droidrun[google,openai], fastapi, uvicorn, vapi-python-sdk, apscheduler.11Configure config.yaml with environment variables (Secrets Management).[ ] Droidrun BootstrappingRun droidrun setup targeting the Mobilerun IP.Validate Accessibility Service status via adb shell settings get secure enabled_accessibility_services.Smoke Test: Run droidrun ping and verify <200ms round-trip time.Phase 2: Core Agent Logic (Days 3-5)[ ] Develop IronClawAgent ClassSubclass DroidAgent. Override run() to include a global exception handler (for app crashes).Implement BioMemory loader: Read profile.json into the LLM system prompt.[ ] Implement "Job Hunter" SkillCreate resume_uploader.py: Logic to adb push files.Develop search_and_apply() workflow.Prompt Engineering: Fine-tune the system prompt with "Few-Shot" examples of identifying "Apply" buttons vs "Save" buttons.Test: Run against a controlled Google Search query.Phase 3: Temporal & Voice Orchestration (Days 6-8)[ ] The Alarm ManagerImplement AlarmTool using ADB Intents (android.intent.action.SET_ALARM).Test reliability: Set alarm for T+1 minute and verify ring.[ ] Vapi IntegrationSet up Vapi account and purchase phone number.6Create POST /api/v1/voice/wake endpoint on Gateway.Implement logic: Scheduler -> Check Location -> Calculate TZ -> Trigger Vapi.[ ] Geolocation ToolImplement parsing logic for dumpsys location. Handle cases where GPS is off (fallback to IP geolocation).Phase 4: Interface & Polish (Days 9-10)[ ] Telegram Bot DeploymentUse python-telegram-bot in async mode.Implement Screenshot forwarding: await bot.send_photo(chat_id, photo=agent.last_screenshot).[ ] Optimization LoopLatency: Enable droidrun caching for UI trees to reduce ADB calls.Cost: Prune the XML tree before sending to Gemini to save tokens (remove Layout nodes, keep Button/TextView).6. Security Analysis and Hardening6.1 The "God Mode" Threat ModelGranting Accessibility Permissions to Droidrun effectively gives the agent "God Mode." It can read 2FA codes, open banking apps, and change settings.Mitigation (App Whitelisting): The Gateway must enforce a strict whitelist of allowed packages (e.g., com.android.chrome, com.google.android.calendar). If the Agent attempts to switch context to com.bank.of.america, the Gateway must immediately issue adb shell input keyevent HOME and terminate the session.6.2 Data Privacy in the CloudRunning personal automation on Mobilerun Cloud implies trust in the cloud provider.Mitigation (Ephemeral Sessions):The resume.pdf should be deleted from the device immediately after upload.The Agent should use Chrome Incognito Mode (--incognito flag in Intent) to prevent saving cookies or history on the shared device.The ADB tunnel ensures that screen streams are not intercepted on the public web.7. Strategic Implications and ConclusionProject Iron Claw demonstrates a paradigm shift in how we build personal agents. By moving from API integration to UI automation, we decouple the agent's capabilities from the developer's permission. If a human can do it on a phone, Iron Claw can do it.This architecture—combining Droidrun for visual reasoning, Mobilerun for persistent execution, and Vapi for active interruption—creates a system that is not just a passive chatbot, but an active participant in the user's life. It parses the past (resumes), manages the present (alarms), and plans the future (job applications), all while the user sleeps.The reliance on Gemini 1.5 Pro's massive context window allows the agent to "understand" UIs without brittle selectors, making the system resilient to app updates. However, the latency of cloud inference remains the primary bottleneck. Future iterations should explore running quantized Vision-Language Models (VLMs) directly on the Mobilerun edge to reduce the "Think" step latency from seconds to milliseconds.This report provides the blueprint. The technology is ready. The execution is now a matter of rigorous engineering.Detailed Appendix: Technical Specifications & Code ConceptsA.1 The DroidAgent Class StructureThe IronClawAgent extends the base DroidAgent to add domain-specific memory and safety checks.Python# Concept Code - Iron Claw Agent
from droidrun import DroidAgent, DroidrunConfig
from typing import List, Dict

class IronClawAgent(DroidAgent):
    def __init__(self, config: DroidrunConfig, bio_memory: Dict):
        super().__init__(config)
        self.bio_memory = bio_memory
        self.safe_packages = ["com.android.chrome", "com.google.android.calendar", "com.google.android.deskclock"]

    async def run_step(self, goal: str):
        # 1. Safety Check: Where am I?
        current_package = await self.adb.get_current_package()
        if current_package not in self.safe_packages and current_package!= "com.google.android.apps.nexuslauncher":
            await self.adb.shell("input keyevent HOME")
            raise SecurityException(f"Agent attempted to access forbidden package: {current_package}")

        # 2. Context Injection
        # Inject bio-memory into the prompt so the LLM knows 'Who I am'
        augmented_goal = f"{goal} \n\n Context: User Name is {self.bio_memory['name']}. Skills: {self.bio_memory['skills']}."
        
        # 3. Standard Droidrun Execution
        return await super().run_step(augmented_goal)
A.2 The Vapi Payload ConfigurationThe Vapi API call is structured to ensure the agent is "pushy" enough to wake the user.JSON{
  "phoneNumberId": "d047-...",
  "customer": {
    "number": "+14155552671"
  },
  "assistant": {
    "transcriber": {
      "provider": "deepgram",
      "model": "nova-2",
      "language": "en"
    },
    "model": {
      "provider": "openai",
      "model": "gpt-4o",
      "systemPrompt": "You are Iron Claw, a ruthless productivity assistant. It is 2 AM. The user must wake up. Do not accept 'I'm up' as an answer. Demand they solve a math riddle. If they get it wrong, tell them to try again. Only end the call when they answer correctly."
    },
    "voice": {
      "provider": "11labs",
      "voiceId": "burt_ Reynolds_clone",
      "stability": 0.5
    },
    "firstMessage": "WAKE UP. This is Iron Claw. Prove you are conscious. What is the square root of 64?"
  }
}
A.3 Comparative Analysis: Iron Claw vs. Traditional BotsFeatureTraditional Bot (API-Based)Iron Claw (UI-Native)Job ApplicationFails on sites with no API. Blocked by anti-bot WAFs.Works on any site. Indistinguishable from human mobile traffic.CalendarCan create events, but cannot resolve conflicts visually or handle specialized calendar apps.Can see visual blocks, use any calendar app (Outlook, Google, Proton), and navigate complex recurrence UIs.AlarmsCannot set system alarms (iOS/Android restriction). Can only send push notifications.Uses native Intents/UI to set reliable system-level alarms that ring even in Do Not Disturb mode.VoicePassive voicemail or standard IVR.Active, context-aware, conversational AI that verifies cognitive wakefulness.MaintenanceHigh. API changes break the bot immediately.Low. Visual changes (colors, minor layout) are handled by the LLM's generalization.This comparison highlights the robustness of the Iron Claw approach. While API bots are faster (milliseconds vs seconds), they are fragile. UI-Native bots are slower but resilient and universally compatible. For a personal assistant, resilience is the metric that matters.